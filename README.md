# PyPy_vs_CPython

## Оглавление

[Интерпретаторы питона](https://github.com/Asklepiad/PyPy_vs_CPython/tree/main#интерпретаторы-питона)

[JIT-компилятор](https://github.com/Asklepiad/PyPy_vs_CPython/tree/main#jit-компилятор)

[Установка PyPy, настройка окружения](https://github.com/Asklepiad/PyPy_vs_CPython/tree/main#установка-PyPy-настройка-окружения)

[Бенчмаркинг и различия](https://github.com/Asklepiad/PyPy_vs_CPython/tree/main#бенчмаркинг-и-различия)

## Интерпретаторы питона

Python - типичная гетерозигота от скрещивания компилируемых и интерпретируемых языков программирования, с соответствующей скоростью исполнения. Схема выполнения питона представлена на риснуке 1:

**Рисунок 1**

Так исходный код компилируется в байт-код. Байт-код - это низкоуровневый код, который, тем не менее, исполняется медленнее машинного кода (в который компилируется, например, код на C). Кроме того, результат работы байт-кода (файл с расширением .pyc) оптимизирует импорт файлов. PVM или виртуальная машина питона - это цикл, который, который обходит инструкции байт-кода и исполняет их.

###  CPython

Все сказанное выше справедливо для CPython - стандартной реализации языка. Это тот самый питон, которым мы пользовались весь год. Своим названием он обязан тому, что написан на C. Больше к этому добавить нечего

### Какие-то еще реализации.

Есть Jython - питон, написанный на Java. Он полезен для тех, кому требуется испортировать классы Java в питон (что бы это не значило). Есть еще IronPython (написан на C#, интегрирован с с платформами .NET и Mono для Windows и Linux соответственно), Stackless, который меняет особенности поточного программирования, и PyPy. О последнем поговорим подробнее.

### PyPy

Если CPython - питон на си, Jython - питон на джаве, то PyPy, говоря грубо, питон на питоне. У него сильно выше скорость и оптимизировано пространство памяти (с бенчмаркингом можно ознакомиться на рисунке 2), но есть ряд особенностей и органичений.

**Рисунок 2**

## JIT-компилятор

JIT-компилятор компилирует (а что еще делать компилятору) байт-код в двоичный код в процессе выполнения программы. При этом схема выполнения питона несколько меняется:

**Рисунок 3**

## Установка PyPy, настройка окружения

### Технические параметры.
- Операционная система: Ubuntu 20.04. 
- Версия Python для CPython - 3.9.13
- Версия Python для PyPy - 3.9.16.
- Версия PyPy - 7.3.11 with GCC 12.2.0
- Conda - miniconda 23.3.1

### Установка, окружение, наполнение

Я загружал PyPy через конду в одноименном виртуальном окружении:

```{bash}
conda create -c conda-forge -n pypy pypy python=3.9
conda activate pypy
```

Далее, находясь в этом окружении, создал еще одно, посредством pip, и настроил новый кернел для ноутбука.

```{bash}
pypy3 -m venv PyPy3
source PyPy3/bin/activate
pypy3 -m pip install ipykernel
ipython kernel install --user --name=PyPy3
```

Для ноутбука из группы сравнения (хороша группа из одной единицы наблюдения) я также создал отдельное окружение в pip.

```{bash}
python3 -m venv cpython
source cpython/bin/activate
pip3 install ipykernel
ipython kernel install --user --name=cpython
```

Чтобы подгрузить библиотеки в окружение с pypy нужно использовать команду ```pypy -m pip install <package>```
в окружение с обычным - посредством стандратного ```pip3 install <package>```

Файлы заисимостей `requirementsCP.txt` и `requirementsPP.txt` в данном репозитории предназначены для окружения с CPython и PyPy соответственно.

## Бенчмаркинг и различия

### Поддержка версий.
Если для работы вам необходим питон версии 3.10 и выше, то PyPy - не ваш выбор. Последняя версия PyPy на момент написания ридми (25.05.23) - 7.3.11 with GCC 12.2.0 поддерживет питон версии 3.9.16. В документации и статьях по ссылкам в конце ридми вы можете встретить информацию, что самая новая версия поддерживает питон 3.6 или 3.7 - эти данные устарели.

### Сборщик мусора

В CPython и PyPy по-разному устроен автоматический сборщик мусора. Это подход, навпраленный на избавление от неиспользуемых объектов, с целью высвободить память для чего-нибудь полезного.

Интерпретатор CPython использует методику подсчета ссылок. Как только на какой-то объект не остается ссылок, усилиями сборщика мусора не остается следа и самого объекта. Это очень логично, но есть два нюанса.
1. Если количество ссылок на большое число объектов примерно одновременно становится равным нулю, это замедляет весь процесс исполнения скрипта - необходимо дождаться, пока сборщик закончит свою работу.
2. Ряд объектов при таком подходе не удалится. Один из вариантов - пример из [статьи](https://realpython.com/pypy-faster-python/#garbage-collection) ниже:
```{python}
class A(object):
    pass
a = A()
a.some_property = a
del a
```
Это связано с тем, что объект имеет ссылку на самого себя. Таким оьразом, число ссылок на объект `a` не равно нулю. И в этой ситуации работает уже другой механизм сборки мусора - периодический сборщик мусора.

Периодический сборщик мусора (cyclic garbage collector) время от времени проходится по всем объектам и проверяет, достижимы ли они. Те из них, которые этому критерию не отвечают, удаляются.

в PyPy используется только периодический сборщик мусора. Это экономит время, поскольку ему больше не нужно считать ссылки. Кроме того, сборщик мусора в PyPy параллелит этот процесс (в CPython он выполнялся монолитно: от начала до конца).

### Базовый питон

### Питон с библиотеками

### Прочее

### Ошибки в ходе бенчмаркинга

## Источники информации и полезные ссылки
[Документация](https://doc.pypy.org/en/latest/index.html)

[Статья на RealPython](https://realpython.com/pypy-faster-python/#python-and-pypy)

Лутц, Марк. Изучаем Python, том 1, 5-е изд.: Пер. с англ. — СПб.: ООО “Диалектика”, 2019. —
832 с.: ил. — Парад, тит. англ.

[Статья на хабре](https://habr.com/ru/articles/209812/) про виды интерпретаторов. Довольно старая, но с хорошими пояснениями.

Полезные кунштюки на стэковерфлоу и стэкэксчэндж: 
- [Юпитер-ноутбук с PyPy](https://stackoverflow.com/questions/33850577/is-it-possible-to-run-a-pypy-kernel-in-the-jupyter-notebook), 
- [Кратко о минусах PyPy](https://stackoverflow.com/questions/18946662/why-shouldnt-i-use-pypy-over-cpython-if-pypy-is-6-3-times-faster), 
- [Обновление cmake](https://askubuntu.com/questions/829310/how-to-upgrade-cmake-in-ubuntu).

